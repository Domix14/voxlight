#version 330 core
out vec3 outColor;

uniform vec3 minBox;
uniform vec3 maxBox;
uniform vec3 chunkSize;
uniform sampler3D chunkTexture;
uniform vec3 sunPos;
uniform vec3 materials[2];

uniform mat4 projection;
uniform mat4 view;
uniform mat4 model;

const vec3 skyColor = vec3(0.529f, 0.8f,  0.92f);

float raycastAABB(vec3 ro, vec3 rd, vec3 volMax, vec3 volMin) {
    float t1 = (volMin.x - ro.x) / rd.x;
    float t2 = (volMax.x - ro.x) / rd.x;
    float t3 = (volMin.y - ro.y) / rd.y;
    float t4 = (volMax.y - ro.y) / rd.y;
    float t5 = (volMin.z - ro.z) / rd.z;
    float t6 = (volMax.z - ro.z) / rd.z;

    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));
    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));

    // if tmax < 0, ray (line) is intersecting AABB, but whole AABB is behing us
    if (tmax < 0) {
        return -1;
    }

    // if tmin > tmax, ray doesn't intersect AABB
    if (tmin > tmax) {
        return -1;
    }

    if (tmin < 0f) {
        return tmax;
    }
    return tmin;
}

float getVoxel(vec3 p) {
    vec3 uv = (p+0.5)/chunkSize;
    return texture(chunkTexture, uv).r;
}

bool raycastToTarget(vec3 ro, vec3 target) {
    vec3 rd = normalize(target - ro);

    const int maxTrace = 0;

    for (int i = 0; i < maxTrace; i++) {
        float hit = getVoxel(floor(ro));
        if (hit != 0) {
            return true;
        }

        ro += rd;

    }

 	return false;
}

vec3 intersect(vec3 ro, vec3 rd) {
    vec3 pos = floor(ro);
    
    vec3 step = sign(rd);
    vec3 tDelta = step / rd;
    
    float tMaxX, tMaxY, tMaxZ;
    
    vec3 fr = fract(ro);
    
    tMaxX = tDelta.x * ((rd.x>0.0) ? (1.0 - fr.x) : fr.x);
    tMaxY = tDelta.y * ((rd.y>0.0) ? (1.0 - fr.y) : fr.y);
    tMaxZ = tDelta.z * ((rd.z>0.0) ? (1.0 - fr.z) : fr.z);

    vec3 norm;
    int maxTrace = 200;
    
    for (int i = 0; i < maxTrace; i++) {
        int hit = int(getVoxel(pos)*255);
        if (hit != 0) {
            return materials[hit-1];
            vec3 offset = vec3(0, 0, 0);
            if(norm.x != 0) {
                offset = rd * (tMaxX - tDelta.x - 0.01);
            } else if(norm.y != 0) {
                offset = rd * (tMaxY - tDelta.y - 0.01);
            } else if(norm.z != 0) {
                offset = rd * (tMaxZ - tDelta.z - 0.01);
            }
            vec3 worldPos = ro + offset;
            bool lighting = raycastToTarget(worldPos, sunPos);
            float lightIntensity = lighting ?  0.5f : 1.0f;
            vec3 color = materials[hit-1];
            
            
            return color * lightIntensity;
        }

        if (tMaxX < tMaxY) {
            if (tMaxZ < tMaxX) {
                tMaxZ += tDelta.z;
                pos.z += step.z;
                if(pos.z >= chunkSize.z || pos.z < 0) {
                    discard;
                    return skyColor;
                }
                norm = vec3(0, 0,-step.z);
            } else {
                tMaxX += tDelta.x;
            	pos.x += step.x;
                if(pos.x >= chunkSize.x || pos.x < 0) {
                    discard;
                    return skyColor;
                }
                norm = vec3(-step.x, 0, 0);
            }
        } else {
            if (tMaxZ < tMaxY) {
                tMaxZ += tDelta.z;
                pos.z += step.z;
                if(pos.z >= chunkSize.z || pos.z < 0) {
                    discard;
                    return skyColor;
                }
                norm = vec3(0, 0, -step.z);
            } else {
            	tMaxY += tDelta.y;
            	pos.y += step.y;
                if(pos.y >= chunkSize.y || pos.y < 0) {
                    discard;
                    return skyColor;
                }
                norm = vec3(0, -step.y, 0);
            }
        }
    }

    discard;
 	return skyColor;
}

void main(){
    vec2 coord = vec2(gl_FragCoord.x/1280, gl_FragCoord.y/720) * 2 - 1;

    vec4 start = inverse(projection*view)*vec4(coord, -1.f, 1.f);
    start /= start.w;
    vec4 end = inverse(projection*view)*vec4(coord, 1.f, 1.f);
    end /= end.w;
    vec3 ro = start.xyz;
    vec3 rd = normalize(end.xyz - start.xyz);

    if(ro.x >= minBox.x && ro.y > minBox.y && ro.z >= minBox.z &&
     ro.x <= maxBox.x && ro.y <= maxBox.y && ro.z <= maxBox.z) {
        ro -= minBox;
        outColor = intersect(ro, rd);
    } else {
        float result = raycastAABB(ro, rd, minBox, maxBox);
        if(result != -1) {
            ro -= minBox;
            outColor = intersect(ro + rd*(result-0.5), rd);
        }
    }
}

/*
uniform vec3 invS;

vec4 tree_lookup(
uniform float N,
vec3 M) // Lookup coordinates    
{
    vec4 I = vec4(0.0, 0.0, 0.0, 0.0);
    vec3 MND = M;
    for (float i=0; i<HRDWTREE_MAX_DEPTH; i++) { // fixed # of iterations
        vec3 P;      // compute lookup coords. within current node
        P = (MND + floor(0.5 + I.xyz * 255.0)) * invS;      // access indirection pool
        if (I.w < 0.9)                   // already in a leaf?
            I = texture(worldMap,P);// no, continue to next depth
            #ifdef DYN_BRANCHING // early exit if hardware supports dynamic branching
            if (I.w > 0.9)    // a leaf has been reached          
                break;
            #endif
            if (I.w < 0.1) // empty cell
                discard;      // compute pos within next depth grid
            MND = MND * N;
    }
    return (I);
}
*/